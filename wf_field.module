<?php
// $Id: wf_field.module,v 1.9 2010/10/14 20:18:42 rfay Exp $

/**
 * @file
 * An example field using the Field API.
 *
 * This is updated from Barry Jaspan's presentation at Drupalcon Paris,
 * @link http://acquia.com/community/resources/acquia-tv/intro-field-api-module-developers Video Presentation @endlink
 *
 * Providing a field requires:
 * - Defining a field
 *   - hook_field_info()
 *   - hook_field_schema()
 *   - hook_field_validate()
 *   - hook_field_is_empty()
 *
 * - Defining a formatter for the field (the portion that outputs the field for
 *   display)
 *   - hook_field_formatter_info()
 *   - hook_field_formatter_view()
 *
 * - Defining a widget for the edit form
 *   - hook_field_widget_info()
 *   - hook_field_widget_form()
 *
 * *
 * See @link field_types Field Types API @endlink
 */


/**
 * Implements hook_field_info().
 *
 * Provides the description of the field.
 */
function wf_field_field_info() {
  return array(
    'wf_state' => array(
      'label' => t('Workflow State'),
      'description' => t('Workflow State.'),
      'default_widget' => 'wf_field_options',
      'default_formatter' => 'wf_field_simple_text',
  ),
  );
}

/**
 * Implements hook_field_validate().
 *
 * Verifies that the chosen workflow state is valid
 */
function wf_field_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  // @todo: permission + transition check - i am not 100% sure this works
  foreach ($items as $delta => $item) {
    $target_options = wf_field_get_current_transition_options($item['wf_state'], $instance, array('include_no_change_option'  => TRUE));
    if ($item['wf_state'] && !isset($target_options[$item['wf_state']]) ) {
      $errors[$field['field_name']][$langcode][$delta][] = array(
        'error' => 'wf_field_invalid',
        'message' => t('We need a valid state.'),
      );
    }
  }
}


function wf_field_field_instance_settings_form($field, $instance) {
  $settings = $instance['settings'];
  $widget = $instance['widget'];
  $form = array();

  $form['wf_settings'] = array(
    '#type' => 'fieldset',
    '#title' => t('Workflow settings'),
    '#collapsible'  => TRUE
  );

  $transitions = wf_field_get_transitions( $instance, array('all_transitions' => TRUE) );

  $form['wf_settings']['wf_states'] = array(
    '#type' => 'fieldset',
    '#title' => t('Define workflow states'),
    '#collapsed' => sizeof($transitions) > 0,
    '#collapsible'  => TRUE,
    '#description' => t('Configure workflow')
  );
  //
  $form['wf_settings']['wf_states']['text']  = array(
    '#type' => 'textarea',
    '#title' => t("One workflow state per line. Workflows are identified by numbers, but can have text descriptions if given on the form '1|draft' or '2|draft (ready for review)'; '3|Publication|Published'"),
    '#default_value' => isset( $settings['wf_settings']['wf_states']['text']   ) ? $settings['wf_settings']['wf_states']['text']  : '',
    '#weight' => -1
  );

  if (is_array($transitions) && sizeof($transitions)) {
    $form['wf_settings']['wf_transitions'] = array(
      '#type' => 'fieldset',
      '#title' => t('Name and define available workflow transitions'),
      '#collapsed' => sizeof($transitions) == 0,
      '#collapsible'  => TRUE,
      '#description' => t('Provide named workflow transitions or disable transition by leaving the transition field blank; all enable/default transitions will have permissions in the !permissions-table.',
    array('!permissions-table' => l('permissions table', 'admin/user/permissions'))),
    );

    foreach ( $transitions as $key => $transition) {
      $field_key = $key;
      $form['wf_settings']['wf_transitions'][$field_key] = array(
        '#type' => 'textfield',
        '#title' => check_plain($transition),
        '#default_value' => (isset( $settings['wf_settings']['wf_transitions'][$field_key])) ?  $settings['wf_settings']['wf_transitions'][$field_key] : '<default>',
        '#description' => t('To disable transition empty field. You can give this transition a name, or leave &lt;default&gt; as a placeholder for automatic "FROM_STATE -> TO_STATE" transition labels.'),
        '#parent' => 'transitions'
        );
    }
  }
  else {
    $form['wf_settings']['wf_transitions'] = array(
      '#type' => 'fieldset',
      '#title' => t('Name and define available workflow transitions'),
      '#collapsed' => FALSE,
      '#collapsible' => FALSE,
      '#description' => t('Please provide some states above first')
    );
  }
  return $form;
}


/**
 * Implements hook_field_is_empty().
 */
function wf_field_field_is_empty($item, $field) {
  return empty($item['wf_state']);
}

/**
 *  Field Type API: Formatter
 *
 *  These are the api hooks that present formatted (themed) output to the
 *  user.
 */

/**
 * Implements hook_field_formatter_info().
 */
function wf_field_field_formatter_info() {
  return array(
  // Simple text
    'wf_field_simple_text' => array(
      'label' => t('Simple text-based formatter'),
      'field types' => array('wf_state'),
  ),
  );
}

/**
 * Implements hook_field_formatter_view().
 *
 * Two formatters are implemented.
 * - wf_field_simple_text just outputs markup indicating the color that
 *   was entered and uses an inline style to set the text color to that value.
 * - wf_field_color_background does the same but also changes the
 *   background color of div.region-content.
 */
function wf_field_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();

  switch ($display['type']) {
    // This formatter simply outputs the field as text and with a color.
    case 'wf_field_simple_text':
      //
      foreach ($items as $delta => $item) {
        // @todo: better
        $element[$delta]['#markup'] =
          '<div class="wf-field-state-' . check_plain($item['wf_state']) . ' wf-field-' . check_plain($instance['field_name']) . '-state-' . check_plain($item['wf_state']) . '">' .
            wf_field_get_current_state_label($item['wf_state'], $instance, array('passive' => TRUE)) .
          '</div>';
      }
      break;
  }

  return $element;
}


/**
 * Field Type API: Widget
 *
 * The widget is the form element used to receive input from the user
 * when the field is being populated.
 */

/**
 * Implements hook_field_widget_info().
 */
function wf_field_field_widget_info() {
  return array(
    'wf_field_options' => array(
       'label' => t('Options'),
       'field types' => array('wf_state'),
    ),
    'wf_field_buttons' => array(
      'label' => t('Buttons'),
      'field types' => array('wf_state'),
    ),
  );
}

/**
 * Implements hook_field_widget_form().
 *
 * Three different forms are provided, for the three widget types.
 *
 * The 'wf_field_colorpicker' and 'wf_field_options' are essentially
 * the same, but wf_field_colorpicker adds a javascript colorpicker
 * helper.
 *
 * wf_field_options displays three text fields, one each for red, green,
 * and blue. However, the field type defines a single text column,
 * rgb, which needs an HTML color spec. Define an element validate
 * handler that converts our r, g, and b fields into a simulated single
 * 'rgb' form element.
 */
function wf_field_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  // detect the default value form
  // @todo - a better way to do this?
  $is_default_value_widget = ( isset($form['#type']) && $form['#type'] == 'fieldset' ) && $form['#title'] == 'Default value' ;


  $value = isset($items[$delta]['wf_state']) ? $items[$delta]['wf_state'] : NULL;
  $widget = $instance['widget'];
  $element += array(
    '#delta' => $delta,
  );
  // default value form gets
  if ($is_default_value_widget) {
    $options = (array) _wf_field_get_states($instance);
    $element['wf_state'] = array(
      '#title' => t('Workflow Default State'),
      '#type' => 'select',
      '#options' => $options,
      '#default_value' => $value,
      '#element_validate' => array('wf_field_options_validate')
    );
  }
  else {
    switch ($widget['type']) {
      case 'wf_field_buttons':
        // no "include_no_change_option"
        $options = (array) wf_field_get_current_transition_options($value, $instance);
        // @todo: find a good "#weight"
        $weight = isset($form['actions']['submit']) ? $form['actions']['submit']['#weight'] + 1 : 100;

        // @todo: is this a good way of doing it?
        $transition_map = array();
        // and then the form buttons
        foreach ($options as $transition => $label ) {
          $form['actions']['wf_field_transition-' . $instance['field_name'] . '-' . $transition] = array(
            '#type' => 'submit',
            '#access' => TRUE,
            '#value' => $label,
            '#weight' => $weight++,
            '#submit' => array('node_form_submit'),
          );
          $transition_map[ $label ] = array('field_name' => $instance['field_name'], 'target_state' => $transition );
        }

        // render a hidden field and transfer value if a button is clicked
        $element['wf_state'] = array(
          '#type' => 'hidden',
          '#default_value' => $value,
          '#element_validate' => array('wf_field_button_widget_hidden_validate'),
          '#transition_map' => $transition_map
        );
        break;
      case 'wf_field_options':
      default:
        $options = (array) wf_field_get_current_transition_options($value, $instance, array('include_no_change_option' => TRUE));
        $element['wf_state'] = array(
          '#title' => t('Workflow Transitions (@current_state_label)', array('@current_state_label' => wf_field_get_current_state_label($value, $instance, array('passive' => TRUE)) )),
          '#type' => 'select',
          '#options' => $options,
          '#default_value' => $value,
          '#element_validate' => array('wf_field_options_validate')
        );
    }

  }

  return $element;
}


/**
 * Validate the individual fields and then convert them into a single HTML RGB
 * value as text.
 */
function wf_field_options_validate($element, &$form_state) {
  // @todo: validate and man i don't understand some of this ...
  $value = $element['#value'];
  form_set_value($element, $value, $form_state);
}

/**
 * Implements hook_field_widget_error().
 */
function wf_field_field_widget_error($element, $error, $form, &$form_state) {
  switch ($error['error']) {
    case 'wf_field_invalid':
      form_error($element, $error['message']);
      break;
  }
}

/**
 * Return all states
 * @param	array		field instance array
 * @param unknown_type $options  passive => TRUE - return (optional) passive label (i.e. Published instead of Publication)
 */
function _wf_field_get_states($instance, $options=array()) {

  if (!isset($instance['settings']['wf_settings']['wf_states']['text']  )) {
    return FALSE;
  }
  $raw_states = explode("\n", trim($instance['settings']['wf_settings']['wf_states']['text']  ));

  // do we want to return the "passive" expression (Published) instead of (Publication)
  $passive = isset($options['passive']) && $options['passive'];

  // Build an array of workflow states on the form (number => name of state).
  // If no state name is given, use the state integer instead.
  $states = array();
  foreach ($raw_states as $state) {
    $parts = explode('|', $state);
    if ($parts[0]) {
      if ($passive && isset($parts[2])) {
        $states[$parts[0]] = trim( ($parts[2]) ? $parts[2] : trim( ($parts[1]) ? $parts[1] : $parts[0] ) );
      }
      else {
        $states[$parts[0]] = trim( ($parts[1]) ? $parts[1] : $parts[0] );
      }
    }
  }

  return $states;
}

/**
 * Return the (named) transitions of an instance
 * @param array $instance
 */
function _wf_field_get_transition_labels($instance) {
  if (!isset($instance['settings']['wf_settings']['wf_transitions'])) {
    return FALSE;
  }
  return $instance['settings']['wf_settings']['wf_transitions'];
}


/**
 * Return the (named) transitions of an instance
 * @param array $instance
 */
function _wf_field_has_transition_label($from, $to, $instance) {
  if (!isset($instance['settings']['wf_settings']['wf_transitions'][$from . '_' . $to]) || !$instance['settings']['wf_settings']['wf_transitions'][$from . '_' . $to]) {
    return FALSE;
  }
  else {
    return $instance['settings']['wf_settings']['wf_transitions'][$from . '_' . $to];
  }
}


function _wf_field_get_all_instances($entity_type=NULL, $bundle_name=NULL) {
  $instances = array();
  if (!isset($entity) && !isset($bundle_name)) {
    $v = field_info_instances($entity_type, $bundle_name);
    foreach ($v as $entity_type => $bundles) {
      foreach ($bundles as $bundle) {
        foreach ($bundle as $instance) {
          // @todo: there must be a way to filter this?
          if (isset($instance['settings']['wf_settings'])) {
            $instances[] = $instance;
          }
        }
      }
    }
  }
  elseif ($entity_type && $bundle_name) {
    $bundle = field_info_instances($entity_type, $bundle_name);
    foreach ($bundle as $instance) {
      // @todo: there must be a way to filter this?
      if (isset($instance['settings']['wf_settings'])) {
        $instances[] = $instance;
      }
    }
  }
  return $instances;
}


/**
 * Helper function for Workflow Fields listing state transitions for a field.
 * @param Array $field
 *   An array with field information, in the form returned by content_fields().
 * @return Array
 *   An array with possible workflow state transitions for the field. Values
 *   are the names of to and from states, as named in the allowed values list.
 *   Keyes are the number of the states, separated by underscore. An example
 *   return could be array('1_2' => 'needs review -> approved').
 */
function wf_field_get_transitions($instance, $options=array() ) {
  $states = _wf_field_get_states($instance);
  if (!is_array($states)) {
    return FALSE;
  }
  // filter by current state
  $filter_from_state=isset($options['filter_from_state']) ? $options['filter_from_state'] : NULL;

  $transition_labels = _wf_field_get_transition_labels($instance);

  // Build an array of the transitions, on the form 0_1 => 'from state -> to state'.
  $transitions = array();

  if (isset($filter_from_state)&&isset($options['include_no_change_option'])&&$options['include_no_change_option']) {
    // Change transition name on current state to 'no changes'
    $transitions[$filter_from_state] = t('No changes');
  }

  // show all / do not hide empty transitions
  $all_transitions = isset($options['all_transitions']) && $options['all_transitions'];
  $no_transition_labels =  isset($options['no_transition_labels']) && $options['no_transition_labels'];
  $ignore_permissions = isset($options['ignore_permissions']) && $options['ignore_permissions'];

  foreach ($states as $from_number => $from_state) {
    foreach ($states as $to_number => $to_state) {
      // Exclude the case where from and to state are the same.
      if ( $from_number != $to_number && ( $all_transitions || _wf_field_has_transition_label($from_number, $to_number, $instance) ) ) {
        $label = _wf_field_has_transition_label($from_number, $to_number, $instance);
        if ( !$label || $label == '<default>' || $no_transition_labels ) {
          $label = t('@from_state -> @to_state', array('@from_state' => $from_state, '@to_state' => $to_state));
        }

        $key = 'wf_field ' . $instance['field_name'] . ' ' . $from_number . '_' . $to_number;
        // check permissions either for this specific transition or all transtion
        if ( $ignore_permissions || user_access( $key ) || user_access( 'wf_field ' . $instance['field_name'] . ' all')) {
          if (!isset($filter_from_state)) {
            $transitions[ $from_number . '_' . $to_number] = $label;
          }
          elseif ( $filter_from_state == $from_number ) {
            $transitions[ $to_number ] = $label;
          }
        }
      }
    }
  }
  return $transitions;
}

function wf_field_get_current_state_label($state, $instance, $options=array()) {
  $states = _wf_field_get_states($instance, $options);
  return isset($states[$state]) ? $states[$state] : t('-');
}

function wf_field_get_current_transition_options($state, $instance, $options=array()) {
  $options['filter_from_state']=$state;
  return wf_field_get_transitions( $instance, $options );
}

// @todo do this for *all* entities
function wf_field_node_update($node) {
  // Get all workflow fields for this node, and if there are any also the
  // unsaved node to detect any workflow state changes.
  $workflow_instances = _wf_field_get_all_instances('node', $node->type);
  if (count($workflow_instances)) {
    $unsaved_node = node_load($node->nid);
  }
  else {
    return NULL;
  }

  // If workflow state has changed, invoke the appropriate rules event.
  global $user;
  foreach ($workflow_instances as $instance) {
    // where does the 'und' come from, wtf?!
    $old_value = isset($unsaved_node->{$instance['field_name']}['und'][0]['wf_state']) ? $unsaved_node->{$instance['field_name']}['und'][0]['wf_state'] : NULL;
    $new_value = $node->{$instance['field_name']}['und'][0]['wf_state'];
    $author = user_load($node->uid);

    if ( $old_value != $new_value ) {
      // The first four lines of the expression below is the name of the
      // workflow event, on the form workflow_fieldname_{FROMSTATE}_{TOSTATE}.
      rules_invoke_event(
        'wf_field_transition_' . $instance['field_name'] . '_' . $old_value . '_' . $new_value, $node, $unsaved_node, $user, $author
      );
    }
    // invoke outbound events
    if (isset($old_value)) {
      rules_invoke_event(
        'wf_field_out_' . $instance['field_name'] . '_' . $old_value, $node, $unsaved_node, $user, $author
      );
    }
    // invoke inbound events
    rules_invoke_event(
      'wf_field_in_' . $instance['field_name'] . '_' . $new_value, $node, $unsaved_node, $user, $author
    );


  }
}

/**
 * Implements hook_perm().
 */
function wf_field_permission() {
  $instances = _wf_field_get_all_instances();
  // Build up a clunky list of all possible transitions.
  $permissions = array();
  foreach ($instances as $instance) {
    $transitions = wf_field_get_transitions($instance, array('all_transitions' => TRUE, 'ignore_permissions' => TRUE));
    foreach ( (array) $transitions as $key => $transition_label ) {
      $permissions['wf_field ' . $instance['field_name'] . ' ' . $key] = array(
        'title' => t('@field_name: transition: @transition_label', array('@field_name' => $instance['field_name'], '@transition_label' => $transition_label))
      );
    }
    $permissions['wf_field ' . $instance['field_name'] . ' all'] = array(
      'title' => t('@field_name: all transitions', array('@field_name' => $instance['field_name']))
    );
  }
  return $permissions;
}

/**
 * Passes the value into the hidden field if a transition-submit button has been "clicked"
 * @param array $element
 * @param array $form_state
 */
function wf_field_button_widget_hidden_validate($element, &$form_state) {
  $op = $form_state['values']['op'];
  if (isset($element['#transition_map'][$op])) {
    $transition = $element['#transition_map'][$op];
    form_set_value($element, $transition['target_state'], $form_state);
  }
}